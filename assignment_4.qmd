---
title: "assignment_4"
format: html
editor: visual
---

# Regionale data fra Eurostat

**MSB105 - Data Science\
Gruppe 4: Hanna Sundal Bjerkreim & Elvar Solheim**

```{r}
#| label: setup
#| message: false
library(tidyverse)
library(readxl)
library(restatapi)
library(DescTools)
library(ggrepel)
library(flextable)
library(modelr)
library(plm)
library(broom)
library(sandwich)
```

I denne oppgaven skal vi hente ned regionale data fra Eurostat, som er EU sin statistikk organisasjon.
Vi skal fokusere på landene Østerrike, Tyskland, Danmark, Frankrike, Hellas, Spania, Italia, Nederland, Belgia, Irland, Polen, Portugal, Norge, Sverige, Finland og Sveits.
Vi skal hente data fra Eurostat ved hjelp av en api fra pakken restapi.
Vi henter regionale GDP data og populasjonsdata for landene på NUTS3 nivå og aggregerer senere opp til NUTS2, NUTS1 og NUTSc nivå.
Vi skal ordne dataene i list-columns, noe som muliggjør et "nested" datasett som inneholder data om brutto-nasjonalprodukt, befolkning, BNP per person og beregnet Gini-koeffisient.
Dataene vil dekke perioden 2000-2020.
Når "nested" datasett er på plass, skal vi produsere ulike plots og estimere noen enkle modeller.

## toc.eurostat

Vi starter med å hente innholdsfortegnelsen fra Eurostat.

```{r}
# Henter innholdsfortegnelse i tekstversjon
toc_txt <- get_eurostat_toc(mode = "txt")
```

## GDP NUTS3

Videre laster vi inn data for brutto-nasjonalprodukt (GDP) på NUTS3-nivå.
Først finner vi en oversikt over Eurostat sine tabeller som både inneholder *GDP* og *NUTS3*.

```{r}
gdp_tabs <- toc_txt |> 
# Regex AND external to regex
   filter(
     str_detect(
       string = title,
       # For å matche både små og store bokstaver
       pattern = '[Gg][Dd][Pp]'
       # AND vha. &
       ) &
     str_detect(
       string = title,
       # For å matche både små og store bokstaver og
       # space eller ikke før 3
       pattern = '[Nn][Uu][Tt][Ss]\\s*3'
       )
     ) |> 
  select(title, code)
```

```{r}
gdp_tabs |> 
  select(title, code) |> 
  flextable()  |> 
  width(1, width = 3.5) |> 
  width(2, width = 1.5)
```

Vi velger å bentytte tabellen med kode nama_10r_3gdp, med følgende forklarende tekst: «Gross domestic product (GDP) at current market prices by NUTS 3 regions».
Vi henter videre «Data Structure Definition» (DSD) for å få en oversikt over hva som finnes i dette datasettet.

```{r}
# DSD for nama_10r_3gdp
dsd_gdp <- get_eurostat_dsd("nama_10r_3gdp")
```

```{r}
dsd_gdp |> 
  head(n = 15) |> 
  flextable()  |> 
  width(1, width = 1) |> 
  width(2, width = 1) |> 
  width(3, width = 3.5)
```

Vi velger MIO_PPS_EU27_2020 som mål på GDP.
Dette gir GDP i løpende priser (million Euro).

```{r}
# Gross domestic product (GDP) at current market prices by NUTS 3 regions 
# id: nama_10r_3gdp
nama_10r_3gdp <- get_eurostat_data(
  id = "nama_10r_3gdp",
  filters = list(
    geo = c("AT", "DE", "DK", "FR", "EL", "ES", 
            "IT", "NL", "BE", "IE", "PL", "PT", "NO", "SE", "FI", "CH"),
    nuts_level = "3",
    unit = "MIO_PPS_EU27_2020"
  ),
  exact_match = FALSE,
  date_filter = 2000:2020,
  stringsAsFactors = FALSE
  ) |> 
  mutate(
    gdp = 1000000 * values
  ) |> 
  select(-c(unit, values)) |> 
  # Vil bare ha NUTS 3 nivå (5 karakterer). Vil aggregere selv til NUTS2,
  # NUTS1 og NUTSc  
  filter(str_length(geo) == 5)
```

## Populasjonsdata

### Oppgave 1

Videre skal vi laste inn data for totalbefolkningen i landene på NUTS3-nivå.
Vi søker etter tabeller fra Eurostat som inneholder både *population* og *NUTS 3*.

```{r}
pop_tabs <- toc_txt |> 
# Regex AND external to regex
   filter(
     str_detect(
       string = title,
       # For å matche både små og store bokstaver
       pattern = '[Pp][Oo][Pp][Uu][Ll][Aa][Tt][Ii][Oo][Nn] '
       # AND vha. &
       ) &
     str_detect(
       string = title,
       # For å matche både små og store bokstaver og
       # space eller ikke før 3
       pattern = '[Nn][Uu][Tt][Ss]\\s*3'
       )
     ) |> 
  select(title, code)
```

```{r}
pop_tabs |> 
  select(title, code) |> 
  flextable()  |> 
  width(1, width = 3.5) |> 
  width(2, width = 1.5)
```

Vi bruker tabellen med teksten: «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions».
Denne tabellen har manglende data for noen regioner, og vi skal senere supplere med data fra tabellen med teksten «Population on 1 January by broad age group, sex and NUTS 3 region».

### Oppgave 2

Tabellen med teksten «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions» har koden nama_10r_3popgdp.
Vi laster ned Data Structure Definition (DSD) for denne tabellen.

```{r}
# DSD for nama_10r_3popgdp
dsd_pop <- get_eurostat_dsd("nama_10r_3popgdp")
```

```{r}
dsd_pop |> 
  head(n = 15) |> 
  flextable()  |> 
  width(1, width = 1) |> 
  width(2, width = 1) |> 
  width(3, width = 3.5)
```

Ut i fra DSD formulerer vi en spørring mot Eurostat og laster ned datasettet «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions».

```{r}
# Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions
# id: nama_10r_3popgdp
nama_10r_3popgdp <- get_eurostat_data(
  id = "nama_10r_3popgdp",
  filters = list(
    geo = c("AT", "DE", "DK", "FR", "EL", "ES", 
            "IT", "NL", "BE", "IE", "PL", "PT", "NO", "SE", "FI", "CH"),
    nuts_level = "3",
    unit = "THS"
  ),
  exact_match = FALSE,
  date_filter = 2000:2020,
  stringsAsFactors = FALSE
  ) |> 
  mutate(pop.x = values * 1000
         ) |>
  select(-c(unit, values)
         ) |>
  # Vil bare ha NUTS 3 nivå (5 karakterer). Vil aggregere selv til NUTS2,
  # NUTS1 og NUTSc  
  filter(str_length(geo) == 5)
```

## Alternative populasjonsdata

### Oppgave 3

Vi skal nå hente ned befolningsdata fra tabellen med teksten «Population on 1 January by broad age group, sex and NUTS 3 region».
Denne tabellen har koden demo_r_pjanaggr3.

```{r}
# DSD for demo_r_pjanaggr3
dsd_pop2 <- get_eurostat_dsd("demo_r_pjanaggr3")
```

```{r}
dsd_pop2 |> 
  head(n = 15) |> 
  flextable()  |> 
  width(1, width = 1) |> 
  width(2, width = 1) |> 
  width(3, width = 3.5)
```

```{r}
# Population on 1 January by broad age group, sex and NUTS 3 region
# id: demo_r_panjanaggr3
demo_r_pjanaggr3 <- get_eurostat_data(
  id = "demo_r_pjanaggr3",
  filters = list(
    geo = c("AT", "DE", "DK", "FR", "EL", "ES", 
            "IT", "NL", "BE", "IE", "PL", "PT", "NO", "SE", "FI", "CH"),
    nuts_level = "3",
    unit = "NR",
    sex = "T",
    age = "TOTAL"
  ),
  exact_match = FALSE,
  date_filter = 2000:2020,
  stringsAsFactors = FALSE,
  ) %>%
  select(geo, time, pop.y = values) |>
  # Vil bare ha NUTS 3 nivå (5 karakterer). Vil aggregere selv til NUTS2,
  # NUTS1 og NUTSc  
  filter(str_length(geo) == 5)
```

## Bearbeiding av populasjonsdata

Vi tar utgangspunkt i populasjonsdata fra tabellen «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions» og supplerer med data fra tabellen «Population on 1 January by broad age group, sex and NUTS 3 region» der data mangler.

### Oppgave 4

Vi sjekker hvilke NUTS 3 soner som inngår i tabellen "Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions", men ikke i tabellen "Population on 1 January by broad age group, sex and NUTS 3 region".

```{r}
setdiff(nama_10r_3popgdp$geo, demo_r_pjanaggr3$geo)
```

### Oppgave 5

Vi sjekker også hvilke NUTS 3 soner som inngår i tabellen «Population on 1 January by broad age group, sex and NUTS 3 region», men ikke i tabellen «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions».

```{r}
setdiff(demo_r_pjanaggr3$geo, nama_10r_3popgdp$geo )
```

### Oppgave 6

Vi skal nå foreta en full join av de to populasjonstabellene, for å få ett samlet datasett med populasjonsdata.

```{r}
# Slår sammen populasjonstabellene
full_pop_nuts3 <- full_join(nama_10r_3popgdp,demo_r_pjanaggr3)
```

### Oppgave 7

Vi sjekker sonene i de nye datasettet full_pop_nuts3 mot dem vi har i GDP tabellen, nama_10_3gdp.

```{r}
setdiff(full_pop_nuts3$geo, nama_10r_3gdp$geo)
```

### Oppgave 8

Vi sjekker også om sonene i GDP tabellen mot dem vi har i full_pop_nuts3.

```{r}
setdiff(nama_10r_3gdp$geo, full_pop_nuts3$geo)
```

### Oppgave 9

\*\*ZZZ er en slags oppsamlingskategori i gdp-dataene.
Vi har ikke tilsvarende for befolkning så disse har vi ingen bruk for.
Vi fjerner \*\*ZZZ sonene fra nama_10r_3gdp.

```{r}
# fjerner **ZZZ regioner
nama_10r_3gdp <- nama_10r_3gdp |>
  filter(!grepl("ZZZ$", geo))
```

### Oppgave 10

Vi ønsker å benytte dataene fra «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions» (pop.x) der disse eksisterer og supplere med data fra «Population on 1 January by broad age group, sex and NUTS 3 region» (pop.y) der vi mangler data.
Mangler vi data i begge tabellene setter vi verdien lik NA.Vi lager en ny variabel pop i full_pop_nuts3 og dropper deretter variablene pop.x og pop.y.

```{r}
# Supplerer med data fra demo_r_pjanaggr3
full_pop_nuts3 <- full_pop_nuts3 |> 
  mutate(
    pop = ifelse(
      test = is.na(pop.x) == TRUE, 
      yes = pop.y, 
      no = pop.x
      )
  ) |> 
  select(-pop.x, -pop.y)
```

### Oppgave 11

Videre undersøkes det om vi har noen NUTS 3 soner med pop lik 0.
Disse rekodes til NA.

```{r}
# Undersøker om det er NUTS3 regioner med pop = 0
if (any(full_pop_nuts3 == 0)) {
  print("Verdier lik 0.")
} else {
  print("Ingen verdier lik 0.")
}
```

```{r}
# Rekoder NUTS3 regioner med pop = 0 til NA
full_pop_nuts3 <- full_pop_nuts3 |>
  mutate(
    pop = ifelse(
      test = pop == 0, 
      yes = NA,
      no = pop
      )
  )
```

### Oppgave 12

Vi har et helt sett av NUTS3 regioner som finnes i befolkningsdata, men ikke i gdp datasettet.
Vi fjerner dem ved hjelp av en left_join der x er gdp-data.
Da legger vi bare til befolkningsdata for de sonene hvor vi har gdp-data.

Vi utfører en left_join() der populasjonsdata blir lagt til datasettet som innholder GDP-data.

```{r}
# Slår sammen GDP datasett og populasjonsdatasett
eu_data <- nama_10r_3gdp |>
  left_join(full_pop_nuts3, join_by(geo, time) )
```

```{r}
dim(eu_data)
```

Vi lager en ny variabel country fra de to første karakterene i NUTS3.

```{r}
# Ny variabel "country"
eu_data <- eu_data |> 
  mutate(
    country = str_sub(geo, start = 1L, end = 2L)
  )
```

Vi sjekker så antall NUTS3 i hvert land.

```{r}
eu_data |> 
  distinct(geo, .keep_all = TRUE) |> 
  group_by(country) |> 
  summarise(Antall = n(), .groups = "drop")
```

Vi sjekker også summary for variablene i eu_data.

```{r}
eu_data |> 
  summary()
```

Vi endrer navn og rekkefølge på variabelen i eu_data.

```{r}
eu_data <- eu_data |> 
  select(country, NUTS3 = geo, year = time, gdp, pop)
```

```{r}
# Rydder opp
# Sletter alle objekt utenom eu_data
rm(list = setdiff(ls(), "eu_data"))
```

### Oppgave 13

Vi beregner gdp_per_capita for hver NUTS3 region for årene 2000-2020 og avrunder til 2 desimaler.

```{r}
# Ny variabel "gdp_per_capita"
eu_data <- eu_data |>
  mutate(gdp_per_capita = round(gdp / pop, 2))

```

Sjekker summary gdp_per_capita.

```{r}
eu_data |>
  select(gdp_per_capita) |> 
  summary()
```

### Oppgave 14

Vi bruker case_when() for å legge til variabelen country_name.
Denne variabelen inkluderer fullt navn på landene.

```{r}
# Ny variabel "country_name"
eu_data <- eu_data |>
  mutate(country_name = case_when(
    country == "AT" ~ "Østerrike",
    country == "BE" ~ "Belgia",
    country == "CH" ~ "Sveits", 
    country == "DE" ~ "Tyskland", 
    country == "DK" ~ "Danmark", 
    country == "EL" ~ "Hellas", 
    country == "ES" ~ "Spania", 
    country == "FI" ~ "Finland", 
    country == "FR" ~ "Frankrike", 
    country == "IE" ~ "Irland", 
    country == "IT" ~ "Italia", 
    country == "NL" ~ "Nederland", 
    country == "NO" ~ "Norge", 
    country == "PL" ~ "Polen", 
    country == "PT" ~ "Portugal", 
    country == "SE" ~ "Sverige"
  ))
```

### Oppgave 15

Vi lager de tre variablene NUTS2, NUTS1 og NUTSc fra NUTS3.
NUTSc er vår egen «oppfinnelse» og angir land (to første karakterer i NUTS kode).

```{r}
# Nye variabler "NUTS2", "NUTS1" og "NUTSc"
eu_data <- eu_data |>
  mutate(
    NUTS2 = str_sub(NUTS3, 1, 4), 
    NUTS1 = str_sub(NUTS3, 1, 3), 
    NUTSc = str_sub(NUTS3, 1, 2)   
  ) |>
  select(
    country_name, country, year, NUTS3, NUTS2, NUTS1, NUTSc, gdp, pop, gdp_per_capita
  )
```

## Beregning av Gini-koeffisient

Vi benytter Gini-koeffisient for å undersøke hvor jevnt *verdiskapningen* er fordelt mellom regioner.
Vi skal nå beregne Gini for hvert år på NUTS2, NUTS1 og NUTSc nivå.
Vi vil beregne Gini utfra gdp_per_capita og pop i NUTS3 for alle aggregeringsnivåene.

### Oppgave 16

Vi begynner med å beregne Gini-koeffisienten for NUTS2.
Vi inkluderer også variablene "pop" og "gdp" for NUTS2.
Disse vil være summen av de tilsvarende NUTS3 nivå.

```{r}
# Gini-koeffisient for NUTS2
gini_NUTS2 <- eu_data |> 
  group_by(NUTS2, country_name, country, year) |>
  summarise(
    gini_nuts2 = Gini(
      x = gdp_per_capita,
      weights = pop,
      na.rm = TRUE
    ),
    pop = sum(pop, na.rm = TRUE),
    gdp = sum(gdp, na.rm = TRUE),
    gdp_per_capita = gdp / pop,
    num_nuts3 = n(),
    .groups = "drop"
    ) |> 
  select(country_name, country, NUTS2, year, pop, gdp, 
         gdp_per_capita, num_nuts3, gini_nuts2)
```

```{r}
gini_NUTS2 |> 
  summary() |> 
  print(width = 80)
```

Vi sjekker observasjoner med Gini avrundet til 0,0000.

```{r}
gini_NUTS2 |> 
  select(-country_name) |> 
  filter(gini_nuts2 < 0.001)
```

### Oppgave 17

Vi beregner nå Gini-koeffisienter på NUTS1 nivå.
Vi inkluderer også variablene "pop" og "gdp" for NUTS1.
Disse vil være summen av de tilsvarende NUTS2 nivå.

```{r}
# Gini-koeffisient for NUTS1
gini_NUTS1 <- eu_data |> 
  group_by(NUTS1, country_name, country, year) |> 
  summarise(
    gini_nuts1 = Gini(
      x = gdp_per_capita,
      weights = pop,
      na.rm = TRUE
    ),
    pop = sum(pop, na.rm = TRUE),
    gdp = sum(gdp, na.rm = TRUE),
    gdp_per_capita = gdp / pop,
    num_nuts3 = n(),
    .groups = "drop"
    ) |> 
  select(country_name, country, NUTS1, year, pop, gdp, 
         gdp_per_capita, num_nuts3, gini_nuts1)
```

```{r}
gini_NUTS1 |> 
  summary() |> 
  print(width = 80)
```

### Oppgave 18

Vi beregner nå Gini-koeffisienter på NUTSc nivå.
Vi inkluderer også variablene "pop" og "gdp" for NUTSc.
Disse vil være summen av de tilsvarende NUTS1 nivå.

```{r}
# Gini-koeffisient for NUTSc
gini_NUTSc <- eu_data |> 
  group_by(NUTSc, country_name, country, year) |> 
  summarise(
    gini_nutsc = Gini(
      x = gdp_per_capita,
      weights = pop,
      na.rm = TRUE
    ),
    pop = sum(pop, na.rm = TRUE),
    gdp = sum(gdp, na.rm = TRUE),
    gdp_per_capita = gdp / pop,
    num_nuts3 = n(),
    .groups = "drop"
    ) |> 
  select(country_name, country, NUTSc, year, pop, gdp, 
         gdp_per_capita, num_nuts3, gini_nutsc)
```

```{r}
gini_NUTSc |> 
  summary() |> 
  print(width = 80)
```

## "Nestete" datastruktur

Vi vil nå «neste» de ulike gini_NUTS\* datasettene og sette dem sammen til et nestet datasett "eu_dataset_nestet" som innholder alle dataene ovenfor i en fint ordnet struktur.

### Oppgave 19

Vi begynner med å "neste" dataene på NUTS2 nivå.

```{r}
# "Nester" NUTS2 data
gini_NUTS2_nest <- gini_NUTS2 |> 
  group_by(country_name, country) |> 
  nest(.key = "NUTS2_data") |> 
  ungroup()
```

### Oppgave 20

Videre "nester" vi dataene på NUTS1 nivå.

```{r}
# "Nester" NUTS1 data
gini_NUTS1_nest <- gini_NUTS1 |>
  group_by(country_name, country) |>
  nest(.key = "NUTS1_data") |>
  ungroup()
```

### Oppgave 21

Vi skal nå "neste" dataene på nasjonsnivå.

```{r}
# "Nester" NUTSc data
gini_NUTSc_nest <- gini_NUTSc |>
  group_by(country_name, country) |>
  nest(.key = "NUTSc_data") |>
  ungroup()
```

### Oppgave 22

Til slutt "nester" vi dataene på NUTS3 nivå og bruker en left_join() til legge til de "nestede" datasettene for NUTS2, NUTS1 og NUTSc.

```{r}
# Gini-koeffisient for NUTS3
gini_NUTS3 <- eu_data |> 
  group_by(NUTS3, country_name, country, year) |>
  
  summarise(
    gini_nuts3 = Gini(
      x = gdp_per_capita,
      weights = pop,
      na.rm = TRUE
    ),
    pop = sum(pop, na.rm = TRUE),
    gdp = sum(gdp, na.rm = TRUE),
    gdp_per_capita = gdp / pop,
    num_nuts3 = n(),
    .groups = "drop"
    ) |> 
  select(country_name, country, NUTS3, year, pop, gdp, 
         gdp_per_capita, num_nuts3, gini_nuts3)
```

```{r}
# "Nester" NUTS3
gini_NUTS3_nest <- gini_NUTS3 |>
  group_by(country_name, country) |>
  nest(.key = "NUTS3_data") |>
  ungroup()
```

```{r}
# Legger til de "nestede" datasettene for NUTS2, NUTS1 og NUTSc
eu_data_nested <- gini_NUTS3_nest |>
  left_join(gini_NUTS2_nest, join_by("country_name", "country")) |>
  left_join(gini_NUTS1_nest, join_by("country_name", "country")) |>
  left_join(gini_NUTSc_nest, join_by("country_name", "country"))
```

```{r}
# Rydder opp
rm(list = setdiff(ls(), c("eu_data", "eu_data_nested")))
```

```{r}
eu_data_nested
```

## Plots som viser utviklingen

### Oppgave 23

Vi skal nå generere ett plott som viser utviklingen i Gini-koeffisient på nasjonsnivå for de 16 landene.

```{r}
eu_data_nested |> 
  unnest(NUTSc_data) |>
  select(year, gini_nutsc, country_name) |>
  ggplot(aes(x = year, y = gini_nutsc, group = country_name, color = country_name)) +
  geom_line()
```

Tabellen under viser Gini i år 2020 for alle landene.

```{r}
eu_data_nested |> 
  unnest(NUTSc_data) |> 
  filter(year == 2020) |> 
  select(country_name, gini_nutsc) |> 
  arrange(desc(gini_nutsc)) |> 
  flextable() |> 
  width(1, width = 1.5) |> 
  width(2, width = 1.5)
```

### Oppgave 24

Ut i fra plottet ser vi at Gini-koeffisienten for Irland skyter til værs fra omlag år 2010.
Irland er også det landet med høyest Gini-verdi.
Vi skal nå se nærmere på utvikling i gini-koeffisient og gdp_per_capita for de ulike NUTS2 sonene i Irland.

I tabellen under ser vi en oversikt over utviklingen i Gini-koeffisient for NUTS2 sonene i Irland.

```{r}
eu_data_nested |> 
  filter(country_name == "Irland") |>
  unnest(NUTS2_data) |> 
  select(NUTS2, year, gini_nuts2) |> 
  flextable() |> 
  width(1, width = 1.5) |> 
  width(2, width = 1.5)
```

I tabellen under ser vi en oversikt over utviklingen i gdp_per_capita for de ulike NUTS2 sonene i Irland.

```{r}
eu_data_nested |> 
  filter(country_name == "Irland") |>
  unnest(NUTS2_data) |> 
  select(NUTS2, year, gdp_per_capita) |> 
  flextable() |> 
  width(1, width = 1.5) |> 
  width(2, width = 1.5)
```

Ut i fra tabellene ser vi en sammenheng mellom utviklingen i Gini-koeffisienten og GDP per capita i Irland.
For IE04 øker Gini-koeffisienten fra 2000 til 2020, noe som indikerer økt ulikhet i verdiskapningen.
Samtidig ser vi en jevn økning i GDP per capita fra 2000 til 2018, men en nedgang i 2019 og 2020.
For IE05 varierer Gini-koeffisienten gjennom årene, men det er en tydelig økning fra 2018 til 2020.
GDP per capita har hatt en jevn økning over hele perioden, med en betydelig økning fra 2018 til 2020.
For IE06 har Gini-koeffisienten variert, men hatt en markant økning fra 2016 til 2020.
GDP per capita har hatt en jevn økning fra 2000 til 2020.
\
\
Det ser ut til å være en tendens til økende ulikhet i alle regionene mot slutten av perioden, spesielt fra 2018 til 2020.
For IE04 og IE06 ser vi at økning i Gini-koeffisienten korrelerer med økning i GDP oer capita.
For IE05 er sammenhengen mer kompleks, da Gini-koeffisienten og GDP per capita varierer uavhenging i visse år.
Kort forklart er årsaken til Irlands spesielle kurver at Apple Inc. restrukturerte sitt skatteopplegg.

## Hvordan er verdiskapningen fordelt mellom regionene i ulike land?

### Spania

#### Oppgave 25

#### Oppgave 26

#### Oppgave 27

#### Oppgave 28

### Tyskland

#### Oppgave 29

#### Oppgave 30

### Frankrike

#### Oppgave 31

#### Oppgave 32

#### Oppgave 33

#### Oppgave 34

#### Oppgave 35

## Enkle modeller

### "Data Science" modeller

#### Oppgave 36

#### Oppgave 37

#### Oppgave 38

#### Oppgave 39

#### Oppgave 40

#### Oppgave 41

#### Oppgave 42

#### Oppgave 43

### Panel modell

#### Oppgave 44

#### Oppgave 45

#### Oppgave 46
